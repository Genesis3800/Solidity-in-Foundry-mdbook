<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Solidity in Foundry</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="Learn Solidity from scratch, using Foundry from the very start.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">About</a></li><li class="chapter-item expanded affix "><a href="GettingStarted.html">Getting Started</a></li><li class="chapter-item expanded affix "><li class="part-title">Solidity Basics</li><li class="chapter-item expanded "><a href="SolidityBasics/HelloWorld/HelloWorld.html"><strong aria-hidden="true">1.</strong> Hello World</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="SolidityBasics/HelloWorld/HelloWorld_contract.html"><strong aria-hidden="true">1.1.</strong> HelloWorld.sol</a></li><li class="chapter-item "><a href="SolidityBasics/HelloWorld/HelloWorld_test.html"><strong aria-hidden="true">1.2.</strong> HelloWorld.t.sol</a></li></ol></li><li class="chapter-item expanded "><a href="SolidityBasics/TypesInSolidity/TypesInSolidity.html"><strong aria-hidden="true">2.</strong> Types in Solidity</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="SolidityBasics/TypesInSolidity/ValueTypes.html"><strong aria-hidden="true">2.1.</strong> Value Types</a></li><li class="chapter-item "><a href="SolidityBasics/TypesInSolidity/ReferenceTypes.html"><strong aria-hidden="true">2.2.</strong> Reference Types</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Applications</li><li class="chapter-item expanded "><a href="Applications/Chainlink/Chainlink.html"><strong aria-hidden="true">3.</strong> Chainlink</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Applications/Chainlink/ChainlinkDataFeeds/ChainlinkDataFeeds.html"><strong aria-hidden="true">3.1.</strong> Chainlink Data Feeds</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Applications/Chainlink/ChainlinkDataFeeds/ChainlinkDataFeeds_contract.html"><strong aria-hidden="true">3.1.1.</strong> DataFeeds.sol</a></li><li class="chapter-item "><a href="Applications/Chainlink/ChainlinkDataFeeds/ChainlinkDatafeeds_test.html"><strong aria-hidden="true">3.1.2.</strong> DataFeeds.t.sol</a></li></ol></li><li class="chapter-item "><a href="Applications/Chainlink/ChainlinkVRF/ChainlinkVRF.html"><strong aria-hidden="true">3.2.</strong> Chainlink VRF</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="Applications/Chainlink/ChainlinkVRF/ChainlinkVRF_contract.html"><strong aria-hidden="true">3.2.1.</strong> VRF.sol</a></li><li class="chapter-item "><a href="Applications/Chainlink/ChainlinkVRF/ChainlinkVRF_test.html"><strong aria-hidden="true">3.2.2.</strong> VRF.t.sol</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Solidity in Foundry</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/Genesis3800/Solidity-in-Foundry-mdbook" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <img src="images/Solidity-in-Foundry-Banner.png" style="border-radius: 20px">
<p>Solidity is the most popular smart contract development language at the time of writing.</p>
<p>I felt there was still a gap to be filled with regards to a comprehensive Solidity book, that starts from scratch and introduces beginners to the latest tech from the very beginning.</p>
<p>This <a href="https://github.com/rust-lang/mdBook">mdbook</a> will start from a barebones <em>hello world</em> contract, and will increase in complexity, as is the case with other books that teach a programming language.</p>
<p>Foundry is a powerful framework that allows us to build, test and deploy smart contracts to the blockchain straight out of the command line. This book will be using Foundry's tooling to write and test our smart contracts.</p>
<p>Most, if not all chapters in this book will contain at least two sections:</p>
<ol>
<li>A section explaining the actual smart contract, and the required concepts.</li>
<li>Another one dedicated to writing a corresponding test, no matter how simple, using Foundry's toolkit.</li>
</ol>
<p>There are two main ways of deriving value from this book:</p>
<ol>
<li>For beginners who just want to learn Solidity but don't want to pick up Foundry for now, you can just read the first section of each chapter, and try to replicate it in the <a href="https://remix.ethereum.org/">Remix IDE</a>.
In case you find the Remix IDE intimidating, you can go through <a href="https://youtu.be/umepbfKp5rI?t=8138">this lesson</a> from Patrick Collins' 32-hour course.</li>
<li>For folks interested in getting started with Foundry, I recommend you follow all sections of each chapter.</li>
</ol>
<p>Here are some resources that this book is inspired by:</p>
<ol>
<li><a href="https://doc.rust-lang.org/book/">The Rust Book.</a></li>
<li><a href="https://book.getfoundry.sh/">The Foundry Book.</a></li>
<li><a href="https://solidity-by-example.org/">Solidity-by-example.</a></li>
<li><a href="https://youtu.be/umepbfKp5rI">Patrick Collins' 32-hour Foundry course.</a></li>
</ol>
<p><strong>TL;DR:</strong> This project is an inspired twist on other sources of learning Solidity. I will be starting from scratch assuming no experience with Solidity. I do however expect a basic understanding of how blockchains work.</p>
<blockquote>
<p>‚ö†Ô∏è  <strong>Full disclosure</strong></p>
<p>I am not in any way associated with the core Foundry team, and don't wanna be seen as piggybacking
off of them.
This mdbook is a personal labour of love, with the final goal being for this to
one day serve as a free, comprehensive and open-sourced resource  for wanabee Solidity devs.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>To follow along, I highly recommend that you install <a href="https://github.com/foundry-rs/foundry">Foundry</a> on your system.
The exact installation instructions might vary depending on your system, but the <a href="https://book.getfoundry.sh/" title="Foundry book">Foundry book</a> is quite comprehensive.</p>
<p>Also, feel free to use <a href="https://remix.ethereum.org/">Remix</a> for an interactive UI to interact with your smart contracts, although I'll be using Foundry throughout.
This will still be a useful resource for you if you decide to stick with Remix, which is more beginner friendly.</p>
<p>Once you have all the CLI tools part of Foundry installed in your system, you can get started by creating a new directory and running:</p>
<pre><code class="language-sh">$  forge init
</code></pre>
<blockquote>
<p>üìù  <strong>Note:</strong>
Foundry is a modular toolchain that consists currently of 4 different CLI tools. We will primarily be using Forge throughout, but
you can read more about each of these tools in the <a href="https://book.getfoundry.sh/">Foundry book</a>.</p>
</blockquote>
<p>You will notice a bunch of new files and directories. Here are the ones you primarily need to worry about for now:</p>
<ol>
<li>
<p><strong>lib</strong>: This directory is where all your dependencies are stored. You will find yourself relying on Solidity code written by others much too often. This directory is where all of that will be stored.</p>
</li>
<li>
<p><strong>src</strong>: The src directory is where you typically store all your smart contract code.</p>
</li>
<li>
<p><strong>test</strong>: The test directory is where you typically store all your test files.</p>
</li>
<li>
<p><strong>script</strong>: This is where you typically write scripts that deploy new smart contracts to the blockchain, and interact with existing ones.</p>
</li>
<li>
<p><strong>foundry.toml</strong>: We can use the toml file to customise virtually all aspects of Foundry's behaviour.</p>
</li>
</ol>
<p>For now, to keep things simple, we will only be working with the src directory. All our code and tests will go inside this directory.</p>
<p>To test if your Foundry project was properly initialized, run:</p>
<pre><code class="language-sh">$  forge build
</code></pre>
<p>This command compiles all the Solidity files within the parent directory, not just the src directory. For now, Forge will simply compile the Solidity code that ships along with the default initialization of a Foundry project.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>Before getting started with our first contract, let us set up the diectory structure I will be following throughout the book.
As I said before, we will be storing all our code within the src directory.</p>
<ol>
<li>Create a directory called <code>SolidityBasics</code> inside <code>src</code>.
This directory will contain all the chapters that deal with basic Solidity Syntax.</li>
<li>Create another directory called <code>HelloWorld</code> inside <code>SolidityBasics</code>.
This directory will contain all the code related to the Hello World contract. Each chapter will have its own directory.</li>
<li>Create a file called <code>HelloWorld.sol</code> inside <code>HelloWorld</code>.</li>
</ol>
<p>Your directory structure should look something like this:</p>
<pre><code class="language-sh">‚îú‚îÄ‚îÄ src/
‚îÇ ‚îú‚îÄ‚îÄ SolidityBasics/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ HelloWorld/
| | ‚îÇ ‚îú‚îÄ‚îÄ HelloWorld.sol
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ HelloWorld.t.sol
</code></pre>
<p>You are now ready to write your first smart contract in Solidity, and learn about what all goes inside a bare-bones smart contract.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="helloworldsol"><a class="header" href="#helloworldsol">HelloWorld.sol</a></h2>
<p>The first line of almost all smart contracts starts something like this:</p>
<pre><code class="language-cpp">// SPDX-License-Identifier: MIT
</code></pre>
<ul>
<li>
<p>The <a href="https://spdx.dev/" title="SPDX license">SPDX license</a> does not have anything to do with the code itself. The Solidity Compiler (solc) encourages the use of a license at the top of every Solidity file to clearly define the copyright legalities of the code.</p>
</li>
<li>
<p>I will be using the MIT license throughout the book, one of the most permissive licenses out there. Any code written in this book is freely available to anyone and everyone for any use.
A full list of all SPDX licenses can be found <a href="https://spdx.org/licenses/" title="on their website">on their website</a>.</p>
</li>
</ul>
<p>Paste this below the License identifier:</p>
<pre><code class="language-cpp">pragma solidity ^0.8.19;
</code></pre>
<ul>
<li>Every Solidity codebase must specify the versions of the <a href="https://www.npmjs.com/package/solc" title="Solidity Compiler(solc)">Solidity Compiler(solc)</a> it is compatible with.</li>
<li>Long story short, code written for older versions of the solc might not be compatible with the newer ones.</li>
<li>It is important therefore, to make sure that the code you are writing is compiled with the correct version of the solc.</li>
</ul>
<p>There are 3 main ways to specify the solc version:</p>
<ol>
<li>
<p><code>pragma solidity ^0.8.0;</code>
This will ensure that your contract is compiled with a solc version equal to or greater than 0.8.0, but less than 0.9.0.
The idea here is to that your contract won't be compiled with a solc version that will break your code.
The solc will introduce breaking changes only with major versions.
These versions have the form 0.x.0 or x.0.0.</p>
</li>
<li>
<p><code>pragma solidity &gt;=0.8.0 &lt;0.8.14;</code>
This is a way to specify the exact range of the solc you want to use in your contract.</p>
</li>
<li>
<p><code>pragma solidity 0.8.0</code>
This way you can make sure your contract only compiles with a specific compiler version.</p>
</li>
</ol>
<p>Now we are ready to initialize a new smart contract using the <code>contract</code> keyword:</p>
<pre><code class="language-cpp">contract HelloWorld { }
</code></pre>
<p>All the code you write goes within these curly brackets.</p>
<blockquote>
<p>üìù  <strong>Note:</strong>
A single Solidity file may contain multiple smart contracts within it. 
Pragma defines the Solidity version for the entire file, not a single contract.</p>
</blockquote>
<p>Our contract consists of a single string that returns the string &quot;Hello world&quot;.
Paste this within the curly brackets:</p>
<pre><code class="language-cpp">string public greeting = &quot;Hello World&quot;;
</code></pre>
<p>And that's it. You created a Hello World smart contract. Your code should look something like this:</p>
<pre><code class="language-cpp">// SPDX-License-Identifier: MIT

pragma solidity ^0.8.19;

contract HelloWorld {

    string public greeting = &quot;Hello World&quot;;
}
</code></pre>
<p>If you are working with Remix, you can compile your contract by clicking <code>Ctrl + S</code>.</p>
<p>If you are working with Foundry, make sure you have a terminal open in the parent directory, the same directory where you initalized the project.
Then run the following command:</p>
<pre><code class="language-sh">forge build
</code></pre>
<p>This command will compile all the Solidity files that exist within the parent directory.
If you've reached this far, and want to write a corresponding test for this contract, create a new file named <code>HelloWorld.t.sol</code> on the same level as this file.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="helloworldtsol"><a class="header" href="#helloworldtsol">HelloWorld.t.sol</a></h2>
<p>Foundry allows us to write tests using Solidity, allowing Solidity developers the comfort of not having to use a language they are not comfortable with.</p>
<p>Each '<em>test</em>' is a single function within a smart contract. These typically have a condition that has to be satisfied.
If the condition is true, the test passes; otherwise it fails.</p>
<p>Since <code>HelloWorld.t.sol</code> is basically another Solidity file from Forge's perspective, it will begin like other Solidity files do:</p>
<pre><code class="language-cpp">// SPDX-License-Identifier: MIT

pragma solidity ^0.8.19;
</code></pre>
<p>Next, we import two smart contracts into this file:</p>
<pre><code class="language-cpp">import &quot;forge-std/Test.sol&quot;;
import &quot;./HelloWorld.sol&quot;;
</code></pre>
<ol>
<li>The first import is the Forge test library, which contains the <code>Test</code> contract. Foundry lets us use its' testing suite by exposing functions from within the test contract to us.</li>
<li>The second import is the smart contract we are testing. </li>
</ol>
<blockquote>
<p>üìù  <strong>Note:</strong>
Please note that Solidity as a language supports inheritance, but not all smart contract languages do so.
Do not worry too much about how inheritance works, we will look into it in more detail later on.</p>
</blockquote>
<p>Next, we initialize the <code>HelloWorld_test</code> contract like this:</p>
<pre><code class="language-cpp">contract HelloWorld_test is Test {

}
</code></pre>
<p>This is the contract that will contain all of our tests. We inherit from the <code>Test</code> contract, which allows us to use the testing suite.</p>
<p>Next, we initialize a test function within the contract like this:</p>
<pre><code class="language-cpp">    function testgreeting() public {
    }
</code></pre>
<p>Within the function, create a new instance of the HelloWorld contract like this:</p>
<pre><code class="language-cpp">   HelloWorld helloWorld = new HelloWorld();
</code></pre>
<p>We can now use the <code>helloWorld</code> variable to access the functions within the <code>HelloWorld</code> contract.
Lastly we use <code>assertEq</code> to assert equality between two values. If the values are equal, the test passes; otherwise it fails.
This is what the test function should look like:</p>
<pre><code class="language-cpp">    function testgreeting() public {
        HelloWorld helloWorld = new HelloWorld();
        assertEq(helloWorld.greeting(), &quot;Hello World&quot;);
    }
</code></pre>
<p>Now understand this carefully.
We use Forge to compile and test our smart contracts. Forge compiles all smart contracts in a codebase indiscriminately. This means that it will compile all smart contracts, including the test contracts.</p>
<p>Forge distingueshes the indiviual test functions by looking at function names. Any function beginning with the string <em>&quot;test&quot;</em> is executed as a test function.
This means that <em>&quot;testgreeting&quot;</em> is a valid name for a test function, but <em>&quot;greetingtest&quot;</em> is not.</p>
<p>Make sure to save your files and compile them using the build command. We can now execute the test function by running the following command:</p>
<pre><code class="language-sh">forge test --match-path src/SolidityBasics/HelloWorld/HelloWorld.t.sol
</code></pre>
<p>We can use the match path flag to specify which test file we want to run. This is useful when we have multiple test files in our codebase, and don't want to run all of them.</p>
<p>This is what your terminal should look like right now:</p>
<img src="SolidityBasics/HelloWorld/../../images/HelloWorld.t.sol_1.png" style="border-radius: 10px">
<p>And that's it!<br />
This is all there is to writing a basic Solidity test in Foundry.
Now there's a variety of different ways to write more complex and comprehensive tests, but we will look into those later on, when we deal with more complex smart contracts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types-in-solidity"><a class="header" href="#types-in-solidity">Types in Solidity</a></h1>
<p>Solidity is a statically typed language, which means that the type of every variable needs to be defined at compile time.
Solidity has many different types for us to use.
They can be broadly classified into two categories:</p>
<h2 id="1-value-types"><a class="header" href="#1-value-types">1. Value Types</a></h2>
<p>Variables of value types store their data in a piece of memory they own.
These variables are passed by value when assigned to new variables or passed as function arguments.
Changing the value of the second variable won't alter the value of the original.
Solidity consists of the following value types:</p>
<ul>
<li>Booleans (<em><code>bool</code></em>)</li>
<li>Unsigned integers (<em><code>uint</code></em>)</li>
<li>Signed integers (<em><code>int</code></em>)</li>
<li>Addresses (<em><code>address</code></em>)</li>
<li>Enums (<em><code>enum</code></em>)</li>
<li>Bytes (<em><code>bytes</code></em>)</li>
</ul>
<h2 id="2-reference-types"><a class="header" href="#2-reference-types">2. Reference Types</a></h2>
<p>Variables of reference types store a reference to the data in a piece of memory they don't own.
That piece of memory could be used by other reference type variables as well.
These variables are passed by reference when assigned to new variables or passed as function arguments.
A change in the value of the second variable can alter the value of the original.
Solidity consists of the following reference types:</p>
<ul>
<li>Arrays (<em><code>[]</code></em>)</li>
<li>Structs (<em><code>struct</code></em>)</li>
<li>Mappings (<em><code>mapping</code></em>)</li>
</ul>
<p>Consider this bit of Solidity code:</p>
<pre><code class="language-cpp">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

contract ValueType_vs_ReferenceType {

    //Value Type
    uint public valueVar1 = 10;
    
    // Reference Type: array of unsigned integers
    uint[] public referenceVar1 = [1, 2, 3];

    function modifyValueType(uint newValue) public view {

        // New Variable assigned the value of valueVar1
        uint valueVar2 = valueVar1;  

        //New variable passed 
        valueVar2 = newValue;
    }

    function modifyReferenceType(uint index, uint newValue) public {
        
        // New variable, referenceVar2, refers to the same storage location as referenceVar1
        uint[] storage referenceVar2 = referenceVar1;  
        
        // Modifying the localReference will modify referenceVar
        referenceVar2[index] = newValue;              
    }

}
</code></pre>
<p>This contract consists of two state variables, and two public functions:</p>
<ol>
<li>
<p><code>modifyValueType()</code> creates a new value type in memory, and assigns it an initial value from the original value type, before finally assigning it the value passed as the function argument.
This won't change the value of <code>valueVar1</code>, since only a temporary copy of the variable was used inside the function.</p>
</li>
<li>
<p><code>modifyReferenceType()</code> creates a new reference type in memory that points to the same storage location as <code>referenceVar1</code>. Any change of value in <code>referenceVar2</code> will also be reflected in <code>referenceVar1</code>.</p>
</li>
</ol>
<p>We can write a small test contract for the snippet as follows:</p>
<pre><code class="language-cpp">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {Test, console2} from &quot;forge-std/Test.sol&quot;;
import &quot;./Types.sol&quot;;

contract Types_test is Test {

    ValueType_vs_ReferenceType types;

    function setUp() public {
        types = new ValueType_vs_ReferenceType();
    }

    function test_modifyValueType() public {
        types.modifyValueType(1234);

        // Check that the value of valueVar1 is still 10
        assertEq(types.valueVar1(), 10);
    }

    function test_modifyReferenceType() public {
        console2.log(&quot;The original value of referenceVar1[0] is&quot;, types.referenceVar1(0));
        types.modifyReferenceType(0, 1234);

        // Check that the value of referenceVar1[0] is now 1234
        assertEq(types.referenceVar1(0), 1234);
    }
}
</code></pre>
<blockquote>
<p>üìù  <strong>Note:</strong>
The <a href="https://github.com/foundry-rs/forge-std/blob/74cfb77e308dd188d2f58864aaf44963ae6b88b1/src/console2.sol"><code>Console2</code></a> library is used to log values to the console. It is imported from the <code>forge-std</code> package, just like the main <code>Test</code> 
library.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="value-types"><a class="header" href="#value-types">Value Types</a></h1>
<h2 id="boolean"><a class="header" href="#boolean">Boolean</a></h2>
<p>A <code>bool</code> variable can have two values: <code>true</code> or <code>false</code>.
Solidity supports the following operations on booleans:</p>
<ul>
<li><code>==</code> (equality)</li>
<li><code>!=</code> (inequality)</li>
<li><code>!</code> (logical negation)</li>
<li><code>||</code> (logical disjunction, ‚ÄúOR‚Äù)</li>
<li><code>&amp;&amp;</code> (logical conjunction, ‚ÄúAND‚Äù)</li>
</ul>
<h2 id="integers"><a class="header" href="#integers">Integers</a></h2>
<p>Solidity supports signed and unsigned integers of various sizes. They are represented using the <code>int</code> and <code>uint</code> keywords respectively, followed by the number of bits they occupy.
For example, <code>int256</code> is a signed integer occupying 256 bits, and <code>uint8</code> is an unsigned integer occupying 8 bits.</p>
<p>Solidity supports integers of sizes 8 bits to 256 bits, in steps of 8.
Integers can be initialized as <code>int</code> or <code>uint</code> without specifying the number of bits they occupy. In this case, they occupy 256 bits.</p>
<blockquote>
<p>üìù  <strong>Note:</strong>
All integers in Solidity are limitied to a certain range. For example, <code>uint256</code> can store a value between 0 and 2<sup>256</sup>-1.
Since <code>int256</code> is a signed integer, it can store a value between -2<sup>255</sup> and 2<sup>255</sup>-1.</p>
</blockquote>
<h2 id="addresses"><a class="header" href="#addresses">Addresses</a></h2>
<p>An <code>address</code> variable stores a 20-byte/160-bits value (size of an Ethereum address).</p>
<blockquote>
<p>üìù  <strong>Note:</strong>
EVM addresses are 40 characters long, however they are often represented as hexadecimal strings with a <code>0x</code> prefix.
But strictly speaking, the address itself is 40 characters.</p>
</blockquote>
<p>Solidity allows us to initialize a variable of type <code>address</code> in two ways:</p>
<ul>
<li><code>address</code>: A simple 20-byte value that represents an EVM address. We can query the balance of an address variable using the <code>balance()</code> method.</li>
<li><code>address payable</code>: Any address variable initialzed with the <code>payable</code> keyword comes with two additional functions, <code>transfer()</code> and <code>send()</code>, that allow us to send ETH to the address.</li>
</ul>
<p>Any integer can be typecasted into an address like this:</p>
<pre><code class="language-cpp">address(1) == address(0x1) == 0x0000000000000000000000000000000000000001
</code></pre>
<p>In this case, the integer <code>1</code> will be treated as a <code>uint160</code>, which can be implicitly converted into an address type.</p>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<p>Enums are a user-defined type that can have upto 256 members. They are declared using the <code>enum</code> keyword.
Each member of an enum corresponds to an integer value, starting from 0.
However, each member can be referenced directly by using its' explicit name.</p>
<p>Consider this example:</p>
<pre><code class="language-cpp">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

contract TestEnum {
    // Define an enum named Directions
    enum Directions { Center, Up, Down, Left, Right }

    // Declare a state variable of type Directions with default value (Center, the first enum member)
    Directions public defaultDirection;

    // Declare and initialize another state variable
    Directions public setDirection = Directions.Right;

    // Change the direction
    function changeDirection(Directions newDirection) public {
        setDirection = newDirection;
    }

    // Get the maximum value of the Directions enum (i.e., Right in this case)
    function getMaxEnumValue() public pure returns (Directions) {
        return type(Directions).max;
    }
}
</code></pre>
<h2 id="fixed-size-byte-arrays"><a class="header" href="#fixed-size-byte-arrays">Fixed-size byte arrays</a></h2>
<p>The <code>bytes</code> type is used to store raw byte data. Even though bytes are always stored as an array of characters, fixed-size byte arrays are a value type, while dynamic-size byte arrays are reference type.</p>
<p>A fixed size byte array can be anywhere between 1 and 32 bytes in size. 
They are declared as:
<code>bytes1</code>, <code>bytes2</code>, <code>bytes3</code>, .............. <code>bytes32</code>.</p>
<p>Each byte can store 2 characters. Therefore, a <code>bytes20</code> variable can store upto 40 characters, enough for an Ethereum address.</p>
<blockquote>
<p>üìù  <strong>Note:</strong>
All byte variables come with a <code>length</code> property that can be used to get the length of the bytes array.</p>
</blockquote>
<p>Here is a code snippet that demonstrates the use of fixed-size byte arrays:</p>
<pre><code class="language-cpp">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

contract ByteContract {

    // Declare a bytes20 variable to store data
    bytes20 public data;

    // Function to set data
    function setData(bytes20 _data) public {
        data = _data;
    }

    // Function to get the length of the bytes variable
    function getFirstByte() public view returns (bytes1) {
        return data[0];
    }

    function getLength() public view returns (uint){
        return data.length;
    }
 
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-types"><a class="header" href="#reference-types">Reference Types</a></h1>
<p>To be Written soon</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chainlink"><a class="header" href="#chainlink">Chainlink</a></h1>
<p><a href="https://chain.link/">Chainlink</a> is a decentralized oracle network that helps inject off-chain data into smart contracts on the blockchain.
As of August 2023, Chainlink is the most widely used oracle network in the blockchain space, and secures billions of dollars in value for smart contracts across many different blockchain networks.
It is crucial for any smart contract developer to be familiar with Chainlink's tooling.</p>
<p>Each sub-section within this section will cover a different Chainlink product.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chainlink-data-feeds"><a class="header" href="#chainlink-data-feeds">Chainlink Data Feeds</a></h1>
<p><a href="https://docs.chain.link/data-feeds#types-of-data-feeds">Chainlink's data feeds</a> are a collection of data points from Chainlink's decentralized oracle network.</p>
<p>Chainlink offers a wide variety of data feeds, but in this tutorial we will be going over their price feeds service.
Each Chainlink price feed returns the relative price of two assets, such as ETH/USD or BTC/USD.</p>
<p>We will write a simple smart contract that consumes Chainlink's data feeds, and then a Foundry test for that smart contract.</p>
<p>Briefly, here is how Chainlink's price feeds service works:</p>
<ol>
<li>
<p>Chainlink has a network of off-chain nodes that fetch the latest prices of different assets and arrive at a consensus in real-time. These prices are fed into an on-chain aggregator contract.</p>
</li>
<li>
<p>Each price feed has its' own aggregator contract.</p>
</li>
<li>
<p>To query the latest relative price of any two assets, we simply need to call the <code>latestRoundData()</code> from the designated contract of that price feed.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chainlinkdatafeedssol"><a class="header" href="#chainlinkdatafeedssol">ChainlinkDataFeeds.sol</a></h1>
<blockquote>
<p>üíª The code corresponding to this page can be found on Github at <a href="https://github.com/Genesis3800/Solidity-in-Foundry-Repo/blob/main/src/Applications/Chainlink/ChainlinkDataFeeds/ChainlinkDataFeeds.sol">DataFeeds.sol</a> üíª</p>
</blockquote>
<p>Before getting started with the actual code, we need to install the dependencies for this project. Make sure you have a Foundry project initialized before moving on.</p>
<h2 id="installing-dependencies"><a class="header" href="#installing-dependencies">Installing dependencies</a></h2>
<p>Dependencies in a Foundry project are managed using <a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">git submodules</a> by default. 
For this project, we will be using a slimmed down version of Chainlink's official smart contracts repo.</p>
<p>To download the repo into the lib directory, run:</p>
<pre><code class="language-sh">forge install https://github.com/smartcontractkit/chainlink-brownie-contracts/
</code></pre>
<p><strong>or simply</strong></p>
<pre><code class="language-sh">forge install chainlink-brownie-contracts
</code></pre>
<blockquote>
<p>üìù  <strong>Note:</strong>
In my experience, Forge may sometimes install outdated versions of the dependencies. Run <code>forge update</code> after installing new
dependencies to make sure you have the latest versions.</p>
</blockquote>
<h2 id="remapping-dependencies"><a class="header" href="#remapping-dependencies">Remapping dependencies</a></h2>
<p>While working with installed dependencies, we may need to explicitly tell Forge where to look for the code.
This can be done by defining your remappings inside a separate file.
To create this file, run:</p>
<pre><code class="language-sh">forge remappings &gt; remappings.txt
</code></pre>
<p>This will create a <code>remappings.txt</code> file in the root directory of your project.
For now, delete everything inside the default remappings file and add the following two remappings inside:</p>
<pre><code class="language-sh">forge-std/=lib/forge-std/src/
@chainlink/=lib/chainlink-brownie-contracts/contracts/src/
</code></pre>
<p>The <code>forge-std</code> remapping is used to tell Forge where to look for the Forge standard library. The <code>@chainlink</code> remapping abstracts away the path to the Chainlink contracts.</p>
<h2 id="writing-the-smart-contract"><a class="header" href="#writing-the-smart-contract">Writing the smart contract</a></h2>
<p>To get started, create a new file called <code>DataFeeds.sol</code> inside your Foundry project.</p>
<p>As mentioned earlier, to use Chainlink's price feeds service, you simply need to query the designated aggregator contract for the specific price feed you want to use.
Since all of Chainlink's pricde feeds contracts are built on top of a single interface, we can use the same interface to interact with all of them.</p>
<p>To get started, import the <code>AggregatorV3Interface</code> into your contract code:</p>
<pre><code class="language-cpp">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import &quot;@chainlink/v0.8/interfaces/AggregatorV3Interface.sol&quot;;
</code></pre>
<p>Next, initialize a contract named <code>ChainlinkDataFeeds </code>:</p>
<pre><code class="language-cpp">contract ChainlinkDataFeeds {
    
}
</code></pre>
<p>Inside the contract:</p>
<ol>
<li>Declare a variable of the type <code>AggregatorV3Interface</code>.</li>
<li>Inside the constructor, initialize the new variable by passing the address of the aggregator contract you want to use.</li>
</ol>
<pre><code class="language-cpp">    AggregatorV3Interface internal immutable priceFeed;

    constructor(address _priceFeed) {
        priceFeed = AggregatorV3Interface(_priceFeed);
    }
</code></pre>
<p>Finally, define a function named <code>getLatestPrice()</code> that performs an external call to the <code>latestRoundData()</code> function of the aggregator contract:</p>
<pre><code class="language-cpp">    function getLatestPrice() public view returns (uint80 roundID, int price) {
        (roundID, price ,,,) = priceFeed.latestRoundData();
        return (roundID, price);
    }
</code></pre>
<p>While we are only dealing with two values, the <code>latestRoundData()</code> function actually returns:</p>
<ol>
<li><code>roundId</code>: Chainlink's data feeds are updated with each 'round'. This value is the ID of the current round.</li>
<li><code>answer</code>: The actual data returned by the data feed. While we are working with price feeds, this value could be anything, depending on the actual data feed you are working with.</li>
<li><code>startedAt</code>: Unix timestamp of when the round started.</li>
<li><code>updatedAt</code>: Unix timestamp of when the round was updated.</li>
<li><code>answeredInRound</code>: <strong>Deprecated</strong></li>
</ol>
<p>And that is it for the contract. Before deploying it though, we need to be familiar with a few concepts related to Chainlink's price feeds:</p>
<ol>
<li>The complete reference for each price feed offered by Chainlink across all of its' networks can be found <a href="https://docs.chain.link/data-feeds/price-feeds/addresses">in their docs</a>.</li>
<li>Different price feeds may vary in their level of precision. For example, on ETH mainnet, the price feed for <code>ETH/USD</code> returns the price in 8 decimals, while the price feed for <code>BTC/ETH</code> returns the price in 18 decimals.
The result needs to be dividied by 10 to the power of the number of decimals to get the actual price.</li>
<li>Each price feed has a set '<em>heartbeat</em>'. This is the default time interval between each update of the price feed.</li>
<li>Each price also has a deviation threshold. If the price deviates from the previous price by more than this percentage, it is updated immediately.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chainlinkdatafeedstsol"><a class="header" href="#chainlinkdatafeedstsol">ChainlinkDataFeeds.t.sol</a></h1>
<blockquote>
<p>üíª The code corresponding to this page can be found on Github at <a href="https://github.com/Genesis3800/Solidity-in-Foundry-Repo/blob/main/src/Applications/Chainlink/ChainlinkDataFeeds/ChainlinkDataFeeds.t.sol">DataFeeds.t.sol</a> üíª</p>
</blockquote>
<p>Create a file named <code>ChainlinkDataFeeds.t.sol</code>. To check if our contract is correctly configured to read from Chainlink's aggregator contracts, we will take the help of the <code>MockV3Aggregator</code> contract.</p>
<p>This contract will mock the behavior of the aggregator contracts, and will allow us to test our contract without having to deploy it to a testnet.
If our contract can read from this mock aggregator contract, it will likely be able to read from the real aggregator contracts as well, since they are built on top of the same interface.</p>
<p>To get started, create a file named <code>DataFeeds.t.sol</code>. Inside the file, make the following imports:</p>
<pre><code class="language-cpp">// SPDX-License-Identifier: MIT

pragma solidity ^0.8.19;

import &quot;forge-std/Test.sol&quot;;
import {ChainlinkDataFeeds} from &quot;./ChainlinkDataFeeds.sol&quot;;
import {MockV3Aggregator} from &quot;@chainlink/v0.8/tests/MockV3Aggregator.sol&quot;;
</code></pre>
<p>Next, initialize a contract named <code>ChainlinkDataFeeds_test</code>:</p>
<pre><code class="language-cpp">contract ChainlinkDataFeeds_test is Test {

}
</code></pre>
<p>The <code>MockV3Aggregator</code> contract needs to be initialized with some dummy data. Declare the following state variables inside the <code>ChainlinkDataFeeds_test</code> contract:</p>
<pre><code class="language-cpp">    // Configuring the base data for the mock aggregator
    uint8 public _decimals = 8;
    int256 public _initialAnswer = 10**18;

    // Initializing the contract instances
    ChainlinkDataFeeds public chainlinkDataFeeds;
    MockV3Aggregator public mockV3aggregator;
</code></pre>
<p>The <code>setUp()</code> function is a special function that if often used while writing tests in Foundry.
This function is executed by Forge before every single test function in a file.
This allows us to set up an initial state that we can use to test our contracts on.</p>
<pre><code class="language-cpp">    function setUp() public {

        mockV3aggregator = new MockV3Aggregator(_decimals, _initialAnswer);
        chainlinkDataFeeds = new ChainlinkDataFeeds(address(mockV3aggregator));
    }
</code></pre>
<p>Finally, we define a function named <code>testgetLatestPrice()</code>.
This function will call the <code>getLatestPrice()</code> function on our contract, which in turn calls the <code>latestRoundData()</code> function on the mock aggregator contract.
We then check if the values returned by the <code>getLatestPrice()</code> function are the same as the values we initialized the mock aggregator contract with.</p>
<p>If the values are in-line with what we expect, we can be certain that our contract is correctly configured to read from Chainlink's aggregator contracts.</p>
<pre><code class="language-cpp">    function testgetLatestPrice() public {

        (uint80 roundID, int256 price) = chainlinkDataFeeds.getLatestPrice();
        
        assertEq(price, _initialAnswer);
        assertEq(roundID, 1);
    }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chainlink-vrf"><a class="header" href="#chainlink-vrf">Chainlink VRF</a></h1>
<p><a href="https://docs.chain.link/docs/chainlink-vrf/">Chainlink VRF</a> is a Chainlink service that allows smart contracts to consume provably fair and verifiable random numbers.
Blockchains by their nature are deterministic in nature, and therefore generating truly random numbers is nigh impossible.</p>
<p>In this tutorial, we will write a simple smart contract that consumes Chainlink's VRF service to return one of these 3 random numbers:
1, 2, or 3.</p>
<ul>
<li>We should get back <em><strong>1</strong></em> with a 1% probability.</li>
<li>We should get back <em><strong>2</strong></em> with a 33% probability.</li>
<li>We should get back <em><strong>3</strong></em> with a 66% probability.</li>
</ul>
<p>Briefly, here is how Chainlink's VRF service works:</p>
<ol>
<li>Your smart contract performs an external call on the VRF coordinator contract, by calling the <code>requestRandomWords()</code> function.</li>
<li>This emits an event that is picked up by Chainlink's off-chain node network.</li>
<li>The off-chain node network generates a random number and sends it back to the coordinator contract.</li>
<li>The coordinator contract sends the generated random number(s) to your smart contract by calling the <code>fulfillRandomWords()</code> function on your smart contract, which you must implement. This serves as the callback function.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chainlinkvrfsol"><a class="header" href="#chainlinkvrfsol">ChainlinkVRF.sol</a></h1>
<blockquote>
<p>üíª The code corresponding to this page can be found on Github at <a href="https://github.com/Genesis3800/Solidity-in-Foundry-Repo/blob/main/src/Applications/Chainlink/ChainlinkVRF/ChainlinkVRF.sol">ChainlinkVRF.sol</a> üíª</p>
</blockquote>
<h2 id="creating-a-vrf-subscription"><a class="header" href="#creating-a-vrf-subscription">Creating a VRF subscription</a></h2>
<p>Unlike the price feeds service, Chainlink VRF is not free to use.
Each randomness request costs a certain amount of LINK tokens.</p>
<p>There are two ways to pay for a VRF request:</p>
<ol>
<li><strong>Direct Funding:</strong> Your smart contract directly pays a small amount of LINK tokens with each request.</li>
<li><strong>Subscription Method:</strong> You fund a single subscription with LINK tokens, and add your smart contracts as approved consumers of that subscription. Each time your smart contract makes a randomness request, the subscription is charged a small amount of LINK tokens.</li>
</ol>
<p>We will be using the subscription method in this tutorial.</p>
<p>These are the steps to set up a VRF subscription:</p>
<ol>
<li>Make sure you have some LINK tokens in an EOA. You can get a few from <a href="https://faucets.chain.link/">Chainlink's faucet</a>.</li>
<li>Go to <a href="https://vrf.chain.link/">vrf.chain.link</a> and create a new subscription. I will be working with the Sepolia testnet.</li>
<li>Fund your subscription with some LINK tokens(50 should be more than enough).</li>
</ol>
<p>We are now ready to start writing our smart contract.</p>
<h2 id="writing-the-smart-contract-1"><a class="header" href="#writing-the-smart-contract-1">Writing the smart contract</a></h2>
<p>To get started, create a new file called <code>ChainlinkVRF.sol</code> inside your Foundry project.</p>
<p>We need to import two things into our contract:</p>
<ol>
<li><code>VRFCoordinatorV2Interface</code>: Each network supported by Chainlink has an on-chain coordinator contract that handles all VRF requests. use this interface to interact with the coordinator contract.</li>
<li><code>VRFConsumerBaseV2</code>: This is an abstract contract, which means this is an incomplete contract with at least one of its functions left unimplemented. We will inherit from this contract and implement the missing function, <code>fulfillRandomWords()</code>.</li>
</ol>
<pre><code class="language-cpp">// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import &quot;@chainlink/v0.8/interfaces/VRFCoordinatorV2Interface.sol&quot;;
import &quot;@chainlink/v0.8/VRFConsumerBaseV2.sol&quot;;
</code></pre>
<p>Next, let us initialize a contract named <code>ChainlinkVRF</code>:</p>
<pre><code class="language-cpp">contract ChainlinkVRF is VRFConsumerBaseV2 {

}
</code></pre>
<p>To send a randomness request to Chainlink VRF, we need to configure a few variables. Let us take a look:</p>
<ul>
<li><code>keyHash</code>: Each <code>keyHash</code> is a hexadecimal value that represents a '<em>gas lane</em>'. Each gas lane costs a different amount of gas.</li>
<li><code>subId</code>: The subscription ID of the subscription we created earlier.</li>
<li><code>minimumRequestConfirmations</code>: The number of blocks you would like the off-chain node to wait before fulfilling your request. The higher this number, the more secure your randomness will be.</li>
<li><code>callbackGasLimit</code>: How much gas would you like to be used on your callback function.</li>
<li><code>numWords</code>: The number of <code>uint256</code> values you would like to receive. We will be requesting 1 word.</li>
</ul>
<blockquote>
<p>üìù  <strong>Note:</strong>
All of these values will differ depending on the network you are working with. You can find the technical reference for all supported
networks <a href="https://docs.chain.link/vrf/v2/subscription/supported-networks">here</a>.</p>
</blockquote>
<p>Let us configure these variables:</p>
<pre><code class="language-cpp">    VRFCoordinatorV2Interface private CoordinatorInterface;
    uint64 private _subscriptionId;
    bytes32 private constant KEY_HASH = 0x474e34a077df58807dbe9c96d3c009b23b3c6d0cce433e59bbf5b34f823bc56c;
    uint32 private constant CALLBACK_GAS_LIMIT = 100000;
    uint16 private constant BLOCK_CONFIRMATIONS = 10;
    uint32 private constant NUM_WORDS = 1;

    // Variable to store the generated random number
    uint256 public number;
</code></pre>
<p>The <code>CoordinatorInterface</code> and <code>_subscriptionId</code> variables will be initialized in the constructor.
The <code>number</code> variable will store the generated random number.</p>
<p>The constructor can be initialized as follows:</p>
<pre><code class="language-cpp">    constructor(uint64 subscriptionId, address vrfCoordinatorV2Address) VRFConsumerBaseV2(vrfCoordinatorV2Address) {
        _subscriptionId = subscriptionId;
        CoordinatorInterface = VRFCoordinatorV2Interface(vrfCoordinatorV2Address);
    }

</code></pre>
<p>Let us now define a function named <code>useChainlinkVRF()</code> that will send a randomness request to the Chainlink VRF coordinator contract.
This function will send a randomness request to the coordinator contract, and return a <code>requestId</code> that will be used to identify the request.</p>
<pre><code class="language-cpp">     function useChainlinkVRF() public returns (uint256 requestId) {
        requestId = CoordinatorInterface.requestRandomWords(
            KEY_HASH,
            _subscriptionId,
            BLOCK_CONFIRMATIONS,
            CALLBACK_GAS_LIMIT,
            NUM_WORDS
        );
        return requestId;
    }
</code></pre>
<p>Lastly, we need to define the <code>fulfillRandomWords()</code> function. This function will be called by the Chainlink VRF coordinator contract once the randomness request has been fulfilled by the off-chain Chainlink node.</p>
<p>We can modulo the huge random number we get back to trim it down to a desired range.
Based on the number we get back, we will set the <code>number</code> variable to 1, 2, or 3.</p>
<pre><code class="language-cpp">    function fulfillRandomWords(uint256 requestId, uint256[] memory randomWords) internal override {

        // To get a random number b/w 1 and 100 inclusive
        uint256 randomNumber = (randomWords[0] % 100) + 1;

        if(randomNumber == 100){
            number = 1;
        } else if(randomNumber % 3 == 0) {
            number = 2;
        } else {
            number = 3;
        }
    }
</code></pre>
<p>And that's it for now.
By calling the <code>useChainlinkVRF()</code> function on our contract, a user can get back a random number b/w 1 and 3 with a varying degree of probability.</p>
<p>In the next section, we will use the <code>VRFCoordinatorV2Mock</code> to write a preliminary test for our VRF contract.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chainlinkvrftsol"><a class="header" href="#chainlinkvrftsol">ChainlinkVRF.t.sol</a></h1>
<blockquote>
<p>üíª The code corresponding to this page can be found on Github at <a href="https://github.com/Genesis3800/Solidity-in-Foundry-Repo/blob/main/src/Applications/Chainlink/ChainlinkVRF/ChainlinkVRF.t.sol">ChainlinkVRF.t.sol</a> üíª</p>
</blockquote>
<p>Create a file named <code>ChainlinkVRF.t.sol</code> inside your Foundry project.</p>
<p>To test our VRF contract using the <code>VRFCoordinatorV2Mock</code>, set up the test file with the following imports:</p>
<pre><code class="language-cpp">// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.19;

import &quot;forge-std/Test.sol&quot;;
import {VRFCoordinatorV2Mock} from &quot;@chainlink/v0.8/mocks/VRFCoordinatorV2Mock.sol&quot;;
import {ChainlinkVRF} from &quot;./ChainlinkVRF.sol&quot;;
</code></pre>
<p>Next, initialize a contract named <code>ChainlinkVRF_test</code>:</p>
<pre><code class="language-cpp">contract ChainlinkVRF_test is Test {

}
</code></pre>
<p>We need to declare a few state variables:</p>
<pre><code class="language-cpp">    // Initializing the contract instances
    ChainlinkVRF public chainlinkVRF;
    VRFCoordinatorV2Mock public vrfCoordinatorV2Mock;

    // These variables will keep a count of the number of times each
    // random number number was generated
    uint counter1; uint counter2; uint counter3;
</code></pre>
<p>The <code>counter1</code>, counter2<code>and</code>counter3<code>variables will keep a count of the number of times each of the respective random numbers was generated. Now let us define the</code>setUp()` function to set up the initial state:</p>
<pre><code class="language-cpp">    function setUp() public {
        vrfCoordinatorV2Mock = new VRFCoordinatorV2Mock(100000000000000000, 1000000000);
        uint64 subId = vrfCoordinatorV2Mock.createSubscription();

        //funding the subscription with 1000 LINK
        vrfCoordinatorV2Mock.fundSubscription(subId, 1000000000000000000000);

        chainlinkVRF = new ChainlinkVRF(subId, address(vrfCoordinatorV2Mock));
        vrfCoordinatorV2Mock.addConsumer(subId, address(chainlinkVRF));
    }
</code></pre>
<p>We do a few things here:</p>
<ol>
<li>We initialize a new <code>VRFCoordinatorV2Mock</code> contract with some dummy values.</li>
<li>Then we programmatically create a new subscription and fund it with 1000 LINK tokens.</li>
<li>Next, we initialize a new instance of the <code>ChainlinkVRF</code> contract.</li>
<li>Finally, we add the <code>ChainlinkVRF</code> contract as an approved consumer of the subscription we created earlier.</li>
</ol>
<p>Let us now create a <code>testrequestRandomWords()</code> function to check if our contract is consuming the VRF service correctly.
This will however be a slightly different test than the ones we have written before.</p>
<p>This function will not have an assertion that it may or may not pass.
Test functions written without any assertions <strong>always</strong> pass. We will however use the <code>console2</code> contract from Forge's test suite to log out the random numbers generated by our contract.</p>
<p>We can check how many times each number was generated by looking at the <code>counter1</code>, <code>counter2</code> and <code>counter3</code> variables.
This will help us see if the probability of the numbers being generated is along the desried lines.</p>
<pre><code class="language-cpp">function testrequestRandomWords() public {

        for(uint i = 0; i &lt; 1000; i++)
        {                    
            uint256 requestId = chainlinkVRF.requestRandomWords();
            vrfCoordinatorV2Mock.fulfillRandomWords(requestId, address(chainlinkVRF));

            if(chainlinkVRF.number() == 1){
                counter1++;
            } else if(chainlinkVRF.number() == 2){
                counter2++;
            } else {
                counter3++;
            }   
        }

        console2.log(&quot;Number of times 1 was generated: &quot;, counter1);
        console2.log(&quot;Number of times 2 was generated: &quot;, counter2);
        console2.log(&quot;Number of times 3 was generated: &quot;, counter3);
    }
</code></pre>
<p>I can run the test file with this command:</p>
<pre><code class="language-bash">forge test --match-path src/Applications/Chainlink/ChainlinkVRF/ChainlinkVRF.t.sol -vv
</code></pre>
<p>Although the exact command may vary on how you have set up your project.
Again, this test will always pass since it does not have any assertions.</p>
<p>However we can derive conclusions by looking at the logged values.
This is what the output of the test looks like on my terminal:</p>
<img src="Applications/Chainlink/ChainlinkVRF/../../../images/ChainlinkVRF.t.sol_1.png" style="border-radius: 10px">

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
